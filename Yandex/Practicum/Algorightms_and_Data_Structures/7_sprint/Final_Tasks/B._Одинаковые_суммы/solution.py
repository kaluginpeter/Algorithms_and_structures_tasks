# -- ПРИНЦИП РАБОТЫ --
# Алгоритм проверяет возможность разбиения множества элементов
# на 2 других множества, таких что, сумма множеств равна друг другу
# и каждый элемент принадлежит начальному супер-множеству.
# Для этого используется подход динамического программирования.
# Для каждой суммы от 1 до половины всей суммы супер-множества, проверяется,
# можно ли создать под-массив заданной суммы. Для ответа проверяется возможность
# создания под-массива суммой (общая сумма / 2)
# -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
# Для решения задачи, используем сведение основной проблемы к задаче о рюкзаке.
# Тем самым, получаем условие: возможно ли создание 2'х рюкзаков, сумма каждого из которых,
# равна x / 2, где x сумма супер-множества. Соответственно для подсчета состояния динамики
# используем классическую формулу задачи о рюкзаке:
# Для подмножества суммой C:
# dp[i][C] = dp[i - 1][C] или dp[i - 1][C - cost(i)], если cost(i) <= C.
# Где i обозначает использование 1, 2, ..., i элементов из супер-множества.
# Соответственно, результат разбиения n элементов из супер-множества, на
# 2 подмножества с равной суммой, будет храниться в dp[n][x/2], где x сумма супер-множества.
# Мы используем оптимизацию затрат памяти на хранения таблицы состояния, так как
# при каждом состоянии, нам требуется текущее и предыдущее состояние, сводя
# потребление памяти с O(NM) до просто O(M), где M это сумма супер-множества.
# Таким образом, алгоритм корректен. ■
# Временная сложность.
# Создание таблицы O(M).
# Симуляция динамического программирования O(NM).
# Итоговая временная сложность: O(NM), где M это сумма элементов множества.
# Пространственная сложность.
# Хранение таблицы состояния динамического программирования O(M).
# Итоговая пространственная сложность: O(M), где M это сумма элементов множества.
import sys


def solution() -> bool:
    n: int = int(sys.stdin.readline().rstrip())
    nums: list[int] = list(map(int, sys.stdin.readline().rstrip().split()))
    total_sum: int = sum(nums)
    if total_sum & 1: return False
    half_sum: int = total_sum >> 1
    dp: list[bool] = [False] * (half_sum + 1)
    dp[0] = True
    for num in nums:
        for subarray_sum in range(half_sum, 0, -1):
            if subarray_sum >= num:
                dp[subarray_sum] = dp[subarray_sum] or dp[subarray_sum - num]
        if num <= half_sum: dp[num] = True
    return dp[half_sum]

if __name__ == '__main__':
    sys.stdout.write(f'{solution()}\n')