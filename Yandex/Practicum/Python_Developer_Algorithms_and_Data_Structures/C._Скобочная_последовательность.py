# C. Скобочная последовательность
# Ограничение времени	1 секунда
# Ограничение памяти	64.0 Мб
# Ввод	стандартный ввод или input.txt
# Вывод	стандартный вывод или output.txt
# Марсоход отправляет на Землю структурированные данные; в структурах применяются скобки трёх разных видов: [], () и {}. Скобки могут быть вложены друг в друга сколько угодно раз.
#
# Всё бы хорошо, но во время жаркого марсианского лета марсоход перегрелся и по неизвестной причине начал путать скобки. Это привело к тому, что открытые скобки остаются незакрытыми и закрывающие скобки не имеют открывающих. Прочесть такую структуру становится невозможно.
#
# В Центре управления марсоходами решили создать программу для контроля за расстановкой скобок. Если в сообщении порядок скобок нарушен, марсоход создаст сообщение заново: в этом случае вероятность повторения ошибок минимальна.
#
# Напишите функцию is_correct_bracket_seq(), которая принимает на вход скобочную последовательность и возвращает True, если последовательность правильная, и False — в остальных случаях.
#
# Что считать правильной последовательностью
# Пустая строка — это правильная скобочная последовательность.
# Правильная скобочная последовательность, взятая в скобки одного типа, — тоже правильная: ( { [ ] } ).
# Правильная скобочная последовательность с приписанной слева или справа правильной скобочной последовательностью — правильная: ( { [ ] } ) ( [ ] ).
# Формат ввода
# На вход подаётся одна строка, содержащая скобочную последовательность. Скобки записаны подряд, без пробелов.
#
# Формат вывода
# True или False.
#
# Пример 1
# Ввод	Вывод
# {[()]}
# True
# Пример 2
# Ввод	Вывод
# ()
# True
# Solution Stack O(N) O(N)
import sys


def parse_input() -> str:
    output: str = sys.stdin.readline().rstrip()
    return output


def is_correct_bracket_seq(sequence: str) -> bool:
    stack: list[str] = list()
    open_brackets: dict[str, str] = {'(': ')', '[': ']', '{': '}'}
    for bracket in sequence:
        if bracket in open_brackets:
            stack.append(bracket)
        elif not stack or open_brackets.get(stack[-1]) != bracket:
            return False
        else:
            stack.pop()
    return len(stack) == 0


def print_answer(answer: bool) -> None:
    sys.stdout.write(str(answer))


def solution() -> None:
    sequence: str = parse_input()
    answer: bool = is_correct_bracket_seq(sequence)
    print_answer(answer)


if __name__ == '__main__':
    solution()