A. Packed Prefix

Язык	Ограничение времени	Ограничение памяти	Ввод	Вывод

Все языки	0.5 секунд	64Mb	стандартный ввод или input.txt	стандартный вывод или output.txt

Node.js 14.15.5	0.5 секунд	128Mb

OpenJDK Java 11	1 секунда	128Mb

C# (MS .NET 6.0 + ASP)	0.5 секунд	128Mb

Python 3.12.1	2 секунды	64Mb

Java 21 (Temurin JDK)	1 секунда	128Mb

Kotlin 1.8.0 (JRE 11)	1 секунда	128Mb

C# (MS .NET 5.0 + ASP)	0.5 секунд	128Mb

Вам даны строки в запакованном виде. Определим запакованную строку (ЗС) рекурсивно.

Строка, состоящая только из строчных букв английского алфавита является ЗС. 

Если A и B —– корректные ЗС, то и AB является ЗС. Если A —– ЗС, а n — однозначное натуральное число, 

то n[A] тоже ЗС. При этом запись n[A] означает, что при распаковке строка A записывается подряд n раз. 

Найдите наибольший общий префикс распакованных строк и выведите его (в распакованном виде).

Формат ввода

В первой строке записано число n (1 ≤ n ≤ 1000) –— число строк.

Далее в n строках записаны запакованные строки. 

Гарантируется, что эти строки корректны, то есть удовлетворяют указанному рекурсивному определению. 

Длина строк после распаковки не превосходит 105.

Формат вывода

Выведите наибольший общий префикс распакованных строк.

Пример 1

Ввод	Вывод

3

2[a]2[ab]

3[a]2[r2[t]]

a2[aa3[b]]

aaa

Пример 2

Ввод	Вывод

3

abacabaca

2[abac]a

3[aba]

aba

Примечания

Сложение подразумевается как конкатенация двух строк.

Умножение строки на число — повтор строки соответствующее число раз.

Пусть функция f умеет принимать ЗС и распаковывать ее. 

Если ЗС D имеет вид D=AB, где A и B тоже ЗС, то f(D) = f(A) + f(B). Если , то f(D) = f(A) × n.
