# -- ПРИНЦИП РАБОТЫ --
#    Алгоритм вычисляет наибольший общий префикс среди строк следующим образом:
#    1) Сначала данная строка декодируется, иначе говоря, распаковывается.
#    2) Затем, если строка является первой по списку, то есть до нее еще не было строк,
#    то она берется за основу, то есть определяется паттерн. Или же, если это не первая строка,
#    то происходит вычисление общего префикса с паттерном. В конце прохода по всему списку строк,
#    результирующий паттерн, будет обозначать наибольший префикс, общий для всех строк.
# -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
#    Для нахождения наибольшего общего префикса строк, воспользуемся свойством
#    транзитивного равенства, которое гласит: "Если А = В и В = С, то А = С".
#    Пусть f(A, B) будет обозначать общий префикс для строк A и В.
#    Значит, если k = f(А, В), а z = f(В, С) при том, что f(А, С) = z, то f(A, C) = k.
#    Следовательно, создадим переменную g обозначающую общий префикс для всех строк.
#    Присвоим значение g равное первому слову, т.к. максимальный префикс для одного слова, равен этому слову.
#    Пройдемся по каждой строке и будем присваивать переменной g, значение:
#        g = f(g, S), где S это строка из списка слов.
#    Отсюда следует инвариант, что в конце прохода по строкам, g будет содержать
#    наибольший общий префикс для всех строк благодаря транзитивному свойству равенства.
#    Таким образом, алгоритм корректен. ■
# Временная сложность
# 1. Распаковка слова O(|S|), где |S| обозначает длину слова S.
# 2. Вычисление общего префикса O(min(|g|, |S|)), где |g| длина паттерна, а |S| длина очередной строки.
# Итоговая временная сложность: O(L), где L суммарная длина всех строк, или же Σ|S| ∈ {S1, S2, ..., Sn}
# Пространственная сложность
# Хранение паттерна в памяти O(|S|), где |S| размер слова.
# Итоговая пространственная сложность: O(M), где M размер самого большого слова.
import sys


def decode_package(package: str) -> str:
    constant: int = 0
    segment: list[str] = []
    callstack: list[tuple[str, int]] = []
    for char in package:
        if char.isdigit():
            constant = constant * 10 + int(char)
        elif char == '[':
            callstack.append((segment, constant))
            segment = []
            constant = 0
        elif char == ']':
            prev_segment, constant = callstack.pop()
            segment = prev_segment + constant * segment
            constant = 0
        else:
            segment.append(char)
    return ''.join(segment)


def solution() -> None:
    n: int = int(sys.stdin.readline().rstrip())
    pattern: int = 0
    p_length: int = 0
    for i in range(n):
        package: str = sys.stdin.readline().rstrip()
        decoded_package: str = decode_package(package)
        if not i:
            pattern = decoded_package
            p_length = len(pattern)
            continue
        idx: int = 0
        while idx < min(p_length, len(decoded_package)):
            if pattern[idx] == decoded_package[idx]:
                idx += 1
            else:
                break
        p_length = idx
    sys.stdout.write('{}\n'.format(pattern[:p_length]))


if __name__ == '__main__':
    solution()