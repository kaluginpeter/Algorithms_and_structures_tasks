# Принцип работы
# Данный алгоритм реализует структуру данных "ассоциативный массив" с использованием метода цепочек.
# Основные операции, поддерживаемые хэш-таблицей, включают добавление, получение и удаление элементов по ключу.
# 1. Хэш-функция:
#     Хэш-функция преобразует ключ в индекс, по которому будет храниться значение в массиве (bucket).
#     Она обрабатывает как положительные, так и отрицательные ключи.
# 2. Добавление элемента (put):
#     При добавлении нового ключа значение помещается в соответствующий индекс bucket,
#     используя хэш-функцию. Если ключ уже существует, обновляется его значение.
# 3. Получение элемента (get):
#     Для получения значения по ключу хэш-таблица вычисляет индекс и проходит по связанному списку,
#     чтобы найти соответствующий ключ. Если ключ найден, возвращается его значение; если нет — выводится "None".
# 4. Удаление элемента (delete):
#     Удаление также начинается с вычисления индекса. Если ключ найден в начале списка, он удаляется,
#     иначе выполняется поиск по связанному списку для удаления ключа.
#
# Доказательство корректности
# Алгоритм корректен, так как:
# - Хэш-функция равномерно распределяет ключи по индексам, благодаря выбору большого простого числа,
#     в качестве размера массива, что минимизирует количество коллизий.
# - Все операции (добавление, получение, удаление) корректно обрабатывают случаи,
#     когда ключа нет в таблице или когда ключ уже существует.
# - Удаление и получение значений учитывают все возможные сценарии, включая начало списка и средние элементы.
# Таким образом, алгоритм корректен. ■
#
# Временная сложность
# 1. Добавление (put):
#     В худшем случае (при высоком уровне коллизий) время добавления элемента будет O(N),
#     где N — количество элементов в хэш-таблице.
#     В среднем случае, при равномерном распределении, временная сложность составляет O(1).
# 2. Получение (get):
#     Аналогично операции добавления,
#     в худшем случае временная сложность может составить O(N), а в среднем случае — O(1).
# 3. Удаление (delete):
#     Как и в предыдущих случаях,
#     в худшем случае временная сложность может быть O(N), в среднем — O(1).
# Таким образом, в среднем временные сложности всех операций составляют O(1), а в худшем случае — O(N).
# Пространственная сложность
# 1. Хранение данных:
#     Хэш-таблица использует массив фиксированного размера (в данном случае  большое простое число 10 000 003).
#     В памяти также хранятся связанные списки для разрешения коллизий.
#     Таким образом, пространственная сложность в худшем случае может достигать O(N), где N — количество элементов.
# 2. Переменные:
#     Используемые переменные для хранения ключей,
#     значений и индексов имеют постоянное количество памяти, что добавляет O(1).
# Итоговая пространственная сложность алгоритма составляет: O(N), где N — количество хранимых элементов.

import sys


class Node:
    def __init__(self, key: int, value: int, next_: 'Node') -> None:
        self.key: int = key
        self.value: int = value
        self.next_: Node = next_


class Hashmap:
    def __init__(self) -> None:
        self.m: int = 10000003
        self.bucket: list[Node] = [None] * self.m

    def hash_function(self, key: int) -> int:
        if key < 0:
            return abs(key + 1001) % self.m
        return key % self.m

    def search(self, idx: int, key: int) -> Node:
        tmp: Node = self.bucket[idx]
        while tmp:
            if tmp.key == key:
                return tmp
            tmp = tmp.next_

    def put(self, key: int, value: int) -> None:
        idx: int = self.hash_function(key)
        tmp: Node = self.search(idx, key)
        if tmp is None:
            self.bucket[idx] = Node(key=key, value=value, next_=self.bucket[idx])
        else:
            tmp.value = value

    def get(self, key: int) -> None:
        idx: int = self.hash_function(key)
        tmp: Node = self.search(idx, key)
        if tmp:
            sys.stdout.write(f'{tmp.value}\n')
            return
        sys.stdout.write('None\n')

    def delete(self, key: int) -> None:
        idx: int = self.hash_function(key)
        tmp: Node = self.bucket[idx]
        if tmp and tmp.key == key:
            sys.stdout.write(f'{tmp.value}\n')
            self.bucket[idx] = tmp.next_
            return
        while tmp and tmp.next_:
            if tmp.next_.key == key:
                sys.stdout.write(f'{tmp.next_.value}\n')
                tmp.next_ = tmp.next_.next_
                return
            tmp = tmp.next_
        sys.stdout.write('None\n')


def solution() -> None:
    n: int = int(sys.stdin.readline().rstrip())
    hashmap: Hashmap = Hashmap()
    for _ in range(n):
        command: str = sys.stdin.readline().rstrip()
        args = command.split()
        getattr(hashmap, args[0])(*map(int, args[1:]))


if __name__ == '__main__':
    solution()
