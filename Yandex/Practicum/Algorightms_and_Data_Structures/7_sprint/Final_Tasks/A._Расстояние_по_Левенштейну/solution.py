# -- ПРИНЦИП РАБОТЫ --
#    Алгоритм вычисляет редакционное расстояния путем динамического программирования.
#    Для каждого состояния динамики при переходе учитывается 3 возможные операции:
#    вставка, удаление и замена символов. Выбирается наименьшее количество требуемых операций
#    и в конце заполнения таблицы, доступен результат минимального расстояния Левенштейна в позиции dp[N][M]
# -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
#    Для нахождения редакционного расстояния будем использовать динамическое программирование.
#    Состоянием dp[i][j] будет означать, минимальное количество различий
#    между подстроками S1, S2, .. Si и T1, T2, ..., Tj. Соответственно вычислив стоимость
#    операций для подстрок меньшего размера, мы можем узнать минимальное редакционное расстояние,
#    по следующему принципу перехода состояния:
#    Для каждого состояния dp[i][j] выбирается минимум из:
#    1) Если S[i] == T[j], то dp[i - 1][j - 1]. Совпадение символов, требуется 0 операций.
#    2) Если S[i] != T[j], то dp[i - 1][j - 1] + 1. Представляем замену j-1'го символа в строке T.
#    3) dp[i][j - 1] + 1. Представляем вставку j-1'го символа в строку T.
#    4) dp[i - 1][j] + 1. Представляем удаление i-1'го символа из строки S.
#    Тогда в таблице dp[N][M] будет храниться минимальное расстояние Левенштейна, т.к в расчетах
#    использовались минимальные расстояния редактирования для префиксов этих строк.
#    Таким образом, алгоритм корректен. ■
# Временная сложность
# 1. Создание таблицы O(M) => O(M)
# 2. Заполнение таблицы O(NM)
# Итоговая временная сложность: O(NM)
# Пространственная сложность
# Хранение таблицы в памяти: O(2M) => O(M)
# Итоговая пространственная сложность: O(M), где M, это длина строки t.
import sys


def solution() -> None:
    s: str = sys.stdin.readline().rstrip()
    t: str = sys.stdin.readline().rstrip()
    n: int = len(s)
    m: int = len(t)
    previous: list[int] = list(range(m + 1))
    current: list[int] = [0] * (m + 1)
    for i in range(1, n + 1):
        for k in range(m + 1): current[k] = i
        for j in range(1, m + 1):
            current[j] = min(
                previous[j - 1] + int(s[i - 1] != t[j - 1]),
                current[j - 1] + 1,
                previous[j] + 1
            )
        previous = current.copy()
    sys.stdout.write(f'{previous[m]}\n')


if __name__ == '__main__':
    solution()