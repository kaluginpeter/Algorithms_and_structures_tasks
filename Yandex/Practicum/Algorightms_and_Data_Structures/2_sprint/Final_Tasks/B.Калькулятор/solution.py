# -- ПРИНЦИП РАБОТЫ --
# Алгоритм использует стек реализованный на динамическом массиве для хранения операндов.
# Дерево принятия решений:
#    1) Инициализация стека
#    2) Создание хеш таблицы с парами <оператор, анонимная функция> для быстрого нахождения и вычисления выражения.
#    3) Итерирование по каждому токену (последовательность символом отделенная пробелом) в выражении:
#           - Если токен принадлежит к операторам, то снять 2 операнда с вершины стека
#               и присвоить их переменным x, y соответственно. Добавить в стек результат вычисления выражения
#               анонимной функцией с операндами x и y.
#           - Иначе, преобразовать токен в число и добавить в стек.
#    4) Вернуть последний элемент в стеке - результат обратной польской нотации.
#
# -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
# Из описания алгоритма следует, что при любом удалении и вставке элемента в стек. Гарантируется инвариант,
#     что для каждого токена t в выражении:
#         Если, t это операция - вычисление верного математического выражения с операндами из стека,
#             где операнды уже были добавлены в стек, как корректные числовые значения.
#         Или если, t это операнд - приведение к числовому типу данных и добавление в стек без изменений.
# Таким образом, алгоритм корректен. ■
#
# -- ВРЕМЕННАЯ СЛОЖНОСТЬ --
# Операции добавления и удаления из стека, выполняются за O(1) по определению стека,
#     основанного на динамическом массиве с амортизированной сложностью добавления и удаления элементов.
# Вычисление математических выражения выполняется за O(1)
# Итоговая временная сложность O(N)
# -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
# Стек потребляет O(N) памяти, для хранения не более N токенов в обратной польской нотации.
# Итоговая пространственная сложность O(N)

import sys
from typing import Callable


def solution(expression: list[str]) -> int:
    stack: list[int] = []
    operators: dict[str, Callable[[int, int], int]] = {
        '+': lambda x, y: y + x,
        '-': lambda x, y: y - x,
        '*': lambda x, y: y * x,
        '/': lambda x, y: y // x,
    }
    for token in expression:
        if token in operators:
            x, y = stack.pop(), stack.pop()
            stack.append(operators[token](x, y))
        else:
            stack.append(int(token))
    return stack.pop()


if __name__ == '__main__':
    expression: list[str] = sys.stdin.readline().rstrip().split()
    sys.stdout.write(str(solution(expression)))