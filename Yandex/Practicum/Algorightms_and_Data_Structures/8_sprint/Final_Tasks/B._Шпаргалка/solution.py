# -- ПРИНЦИП РАБОТЫ --
# Алгоритм использует префиксное дерево, чтобы быстро находить необходимое слово,
# которое подходит под определенный отрезок текста. При этом подход динамического программирования
# позволяет вычислить, можно ли разбить строку целиком довольствуясь, лишь выделенными словами.
# -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
# Для решения задачи, первоначально заполним дерево, вставив каждое доступное нам слово.
# Затем создадим булев вектор, который будет обозначать, "можно ли сформировать dp[i] символ текста,
# воспользовавшись словами из набора".
# Пометим dp[|S|] = True, т.к пустую подстроку S[|S|:) размером 0, мы можем сформировать и без использования слов.
# Начнем проходить справа-налево с конца строки, переменная left, будет обозначать начало подстроки текста S[left:).
# Во внутреннем цикле right будет обозначать конец подстроки в полу-интервале S[left:right).
# Будет идти right слева-направо, начиная с left + 1 и до |S| + 1. Для каждой подстроки S[left:right),
# проверяем, есть ли равное этой подстроке слово, с помощью посимвольной проверки в префиксном дереве.
# Если мы нашли слово, равное подстроке S[left:right) и мы можем сформировать подстроку S[right:), то
# обозначаем dp[left] равным True, это значит, что мы можем расширить строку S[right:), до подстроки S[right-|word|:).
# После прохода динамики, если dp[0], то это значит, что мы можем разобрать строку S[0:|S|), используя только
# допустимые слова.
# Таким образом, алгоритм корректен. ■
# Временная сложность.
# Добавление слов в префиксное дерево O(NK), где N это количество слов, а K средняя длина слова.
# Создание массива состояний динамического программирования O(M), где M это размер текста.
# Вычисление динамики O(M^2), где M это размер текста.
# Итоговая временная сложность: O(NK + M^2).
# Пространственная сложность.
# Хранение слов в префиксном дереве O(NK), где N это количество слов, а K средняя длина слова.
# Хранение текста O(M), где M это размер текста.
# Хранение таблицы состояния динамического программирования O(M), где M это размер текста.
# Итоговая пространственная сложность: O(NK + M).
import sys
from collections import defaultdict


class TrieNode:
    def __init__(self) -> None:
        self.is_word: bool = False
        self.child: dict[str, TrieNode] = defaultdict(TrieNode)

    def add_word(self, word: str) -> None:
        cur: TrieNode = self
        for char in word:
            cur = cur.child[char]
        cur.is_word = True


def solution() -> None:
    sentence: str = sys.stdin.readline().rstrip()
    n: int = int(sys.stdin.readline().rstrip())
    root: TrieNode = TrieNode()
    for _ in range(n):
        word: str = sys.stdin.readline().rstrip()
        root.add_word(word)

    m: int = len(sentence)
    dp: list[bool] = [False] * (m + 1)
    dp[0] = True
    for left in range(0, m + 1):
        if not dp[left]: continue
        cur: TrieNode = root
        for right in range(left + 1, m + 1):
            char: str = sentence[right - 1]
            if char not in cur.child: break
            cur = cur.child[char]
            if cur.is_word: dp[right] = True

    sys.stdout.write('{}\n'.format('YES' if dp[m] else 'NO'))


if __name__ == '__main__':
    solution()