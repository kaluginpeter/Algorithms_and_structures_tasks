K. Выведи диапазон

Ограничение времени	3 секунды

Ограничение памяти	128Mb

Ввод	стандартный ввод или input.txt

Вывод	стандартный вывод или output.txt

Напишите функцию, которая будет выводить по неубыванию все ключи от 
L
 до 
R
 включительно в заданном бинарном дереве поиска.

Ключи в дереве могут повторяться. Решение должно иметь сложность 
O
(
h
+
k
)
, где 
h
 –— глубина дерева, 
k
 — число элементов в ответе.

В данной задаче если в узле содержится ключ 
x
, то другие ключи, равные 
x
, могут быть как в правом, так и в левом поддереве данного узла. 

(Дерево строил стажёр, так что ничего страшного).

PIC

Используйте заготовки кода для данной задачи, расположенные по ссылкам:

c++

Java

js

Python

C#

go

Kotlin

Swift

Формат ввода

На вход функции подаётся корень дерева и искомый ключ. Число вершин в дереве не превосходит 

1

0

5

. Ключи – натуральные числа, не превосходящие 

1

0

9

. Гарантируется, что 
L
≤
R
.
В итоговом решении не надо определять свою структуру / свой класс, описывающий вершину дерева.

Вы можете ознакомиться с инструкцией по работе с Make на платформе в разделе "Начало тема «Введение в алгоритмы», урок «Оптимизация ввода и вывода»

Формат вывода

Функция должна напечатать по неубыванию все ключи от 
L
 до 
R
 по одному в строке.