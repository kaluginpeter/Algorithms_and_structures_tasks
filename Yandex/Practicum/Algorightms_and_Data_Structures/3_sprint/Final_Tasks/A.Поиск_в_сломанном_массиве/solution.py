# -- ПРИНЦИП РАБОТЫ --
# Алгоритм выполняет бинарный поиск по следующему принципу:
#    Инициализируются 2 указателя на границы массива(left и right соответственно).
#    Далее, выполняется цикл, пока указатели не перехлестнутся, т.е пока left <= right
#        Внутри цикла вычисляется середина границы интервала [left, right] с округлением вниз
#        (для деления с округлением вниз, используется усечение бита, иначе говоря "сдвиг 1 бита вправо"),
#        middle = left + ((right - left) >> 1)
#        Затем проверяется условные ветвления:
#            1) Если элемент под индексом middle равен target, то число найдено, возвращаем middle индекс.
#            2)
#                2.1) Если элемент под индексом middle меньше элемента под правой границы, то:
#                    target может находиться либо
#                        - в полу-интервале (middle, right], в таком случае left = middle + 1
#                        - либо в полу-интервале [left, middle), тогда right = middle - 1
#                2.2) Если элемент под индексом middle меньше либо равен элементу под правой границы, то:
#                    target может находиться либо
#                        - в полу-интервале [left, middle), в таком случае right = middle - 1
#                        - в полу-интервале (middle, right], тогда left = middle + 1
#            3) После окончания цикла, возвращается значение "-1", т.к элемент не найден .
# -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
#     Назовем серединный индекс, буквой "m", лежащим в диапазоне left <= m <= right,
#         а число которое требуется найти, буквой "x" тогда для следующих условий, будет верно выражение:
#             Если array[m] < array[right], то array[i] <= array[i + 1], для каждого i в под-отрезке [m, right].
#                 Из этого следует, что, если x > array[m], то x должен находиться в полу-интервале (m, right],
#                     иначе x лежит в под-отрезке [left, m).
#             Если array[m] >= right, то array[i] <= array[i + 1], для каждого i в под-отрезке [left, m].
#                 Из этого следует, что, если x <= array[m], то x должен находиться в полу-интервале [left, m],
#                     иначе x лежит в под-отрезке (m, right]
#         Если left > right, это значит, что x не находится в под-отрезке [left, right], где left и right,
#             это границы массива, соответственно верен следующий инвариант:
#                 array[i] != x для каждого i в [left, right].
# Таким образом, алгоритм корректен. ■

# -- ВРЕМЕННАЯ СЛОЖНОСТЬ --
# На каждой итерации поиска под-отрезок [left, right], сокращается в |_N / 2_| раза, где N = right - left + 1.
# Значит общее количество итераций прямо пропорционально |_log2(N)_|,
#     тогда в худшем случае, поиск выполниться O(log(N)) раз.
# Итоговая временная сложность O(logN)
# -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
# Алгоритм использует переменные, потребляя постоянное количество памяти.
# Итоговая пространственная сложность O(1)

def broken_search(nums: list[int], target: int) -> int:
    n: int = len(nums)
    left: int = 0
    right: int = n - 1
    while left <= right:
        middle: int = left + ((right - left) >> 1)
        if nums[middle] == target:
            return middle
        elif nums[middle] < nums[right]:
            if nums[middle] < target <= nums[right]:
                left = middle + 1
            else: right = middle - 1
        else:
            if nums[left] <= target < nums[middle]: right = middle - 1
            else: left = middle + 1
    return -1

def test():
    arr = [19, 21, 100, 101, 1, 4, 5, 7, 12]
    assert broken_search(arr, 5) == 6