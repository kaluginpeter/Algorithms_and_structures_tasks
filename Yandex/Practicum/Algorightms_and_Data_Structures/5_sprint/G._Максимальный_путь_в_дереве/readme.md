G. Максимальный путь в дереве

Ограничение времени	1 секунда

Ограничение памяти	64Mb

Ввод	стандартный ввод или input.txt

Вывод	стандартный вывод или output.txt

Тимофей устраивает соревнования по спортивному ориентированию в своём офисе.

Схема офиса представлена в виде дерева.

Посещая каждый пункт, можно зарабатывать или терять очки.

Если в узле записано положительное число, это значение добавляется

к текущему количеству очков участника. Если отрицательное —– очки вычитаются. Если 
0
 –— их количество не меняется.

Нужно определить, какое максимальное число очков можно заработать,

пройдя по пути из какого-то пункта 
A
 в какой-то (возможно, тот же) пункт 
B
.

Путь не обязательно должен проходить через корень или содержать лист. Путь должен содержать по крайней мере один узел.

Пример 1:

В дереве всего три вершины, во всех вершинах записаны положительные числа, поэтому объединим все три вершины в один путь. В ответе получим: 
1
+
1
+
2
=
4
.

Пример 2:

Теперь в дереве есть вершина с отрицательным весом, через неё в данном случае проходить будет невыгодно. Оптимальный путь: 
2
+
7
+
3
=
1
2
.

Пример 3:

Оптимальный путь: 
7
+
2
+
3
+
9
=
2
1
.

Пример 4:

В этот раз имеет смысл пройти через вершину с отрицательным весом, так как в левом поддереве вершины 
−
3
 лежит 
5
. Оптимальный путь: 
2
+
2
−
3
+
5
=
6
.

Требования к решению: передаваемое в качестве аргумента дерево нельзя менять.

Не храните вспомогательную информацию в вершинах.

PIC

PIC

Используйте заготовки кода для данной задачи, расположенные по ссылкам:

c++

Java

js

Python

C#

go

Kotlin

Swift

Формат ввода

На вход подается корень дерева.


Вы можете ознакомиться с инструкцией по работе с Make на платформе в разделе "Начало тема «Введение в алгоритмы», урок «Оптимизация ввода и вывода»

Формат вывода

Функция должна вернуть число, равное максимальному количеству очков, 

которое можно заработать, попав из пункта А в пункт В.