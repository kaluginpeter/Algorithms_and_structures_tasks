# -- ПРИНЦИП РАБОТЫ --
# Алгоритм находит все доступные острова и считает остров с наибольшей площадью.
#    Идем по матрице и проверяем, если текущая вершина земля,
#    то выполняем поиск в глубину, считаем остров и проверяем максимальную площадь.
#    Выводим количество островов и наибольшую площадь.
#    Для поиска в глубину, начинаем со стартовой ячейки, помечаем ее, водой..
#    Далее симулируем соседние направления, если соседняя ячейка земля,
#    то добавляем ее в стек и увеличиваем площадь текущего острова. Повторяем процесс, пока стек не пуст.
#    В конце выводим площадь острова.
# -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
# Алгоритм корректно находит все острова и наибольшую площадь, так, как:
# Для каждой "суши" поиск в глубину находит площадь острова и обозначает,
# все входящие в него ячейки, как посещенные и заодно, считает его площадь.
# Если мы не находим землю, то это значит, что текущий остров уже был обработан предыдущими вызовами
# поиска в глубину или это изначально было вода. Если остров не изведан,
# то это значит, что мы нашли новый остров, который отделялся
# от ранее посещенного неразрывными блоками воды. Повторяем процедуру, пока не пройдем через всю матрицу.
# Матрица посещенных вершин, позволяет нам в худшем случае выполнить O(NM) операций
# и не посещать исследованную ячейку повторно.
# Таким образом, алгоритм корректен. ■
# Временная сложность
# Обход всей матрицы - O(NM)
# Проверка на посещенность - O(1)
# Вызов dfs - O(NM)
# Итоговая временная сложность: O(NM)
# Пространственная сложность
# Хранение стека вызовов в массиве call_stack - O(NM)
# Итоговая пространственная сложность: O(NM).

import sys

LAND: str = '#'
DIRECTIONS: list[tuple[int, int]] = [
    (0, 1), (0, -1), (1, 0), (-1, 0)
]


def dfs(start_row: int, start_col: int, matrix: list[list[str]], n: int, m: int) -> int:
    area: int = 1
    matrix[start_row][start_col] = '.'
    call_stack: list[tuple[int, int]] = [(start_row, start_col)]
    while call_stack:
        row, col = call_stack.pop()
        for x, y in DIRECTIONS:
            next_row, next_col = row + x, col + y
            if (
                (0 <= next_row < n and 0 <= next_col < m)
                and (matrix[next_row][next_col] == LAND)
            ):
                call_stack.append((next_row, next_col))
                matrix[next_row][next_col] = '.'
                area += 1
    return area


def solution() -> None:
    n, m = map(int, sys.stdin.readline().rstrip().split())
    matrix: list[list[str]] = []
    for _ in range(n):
        row: list[str] = list(sys.stdin.readline().rstrip())
        matrix.append(row)
    islands: int = 0
    max_area: int = 0
    for row in range(n):
        for col in range(m):
            if matrix[row][col] == LAND:
                islands += 1
                max_area = max(max_area, dfs(row, col, matrix, n, m))
    sys.stdout.write(f'{islands} {max_area}\n')


if __name__ == '__main__':
    solution()